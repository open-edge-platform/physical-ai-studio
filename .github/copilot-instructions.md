# GitHub Copilot Instructions for Geti Action

## Project Overview
This is the Geti Action project, a full-stack application with:
- **Backend**: Python-based FastAPI application (`application/backend/`)
- **Frontend**: React/TypeScript UI (`application/ui/`)
- **Library**: Core Python library for action recognition (`library/`)

## Coding Standards

### Python Environment Management
- **Always use `uv`** for Python package management and virtual environment creation
- Use virtual environments generated by `uv` (typically `.venv`)
- Install dependencies with `uv pip install` or `uv sync`
- Create new environments with `uv venv`
- Never use `pip` directly; always use `uv pip` for faster, more reliable package management
- Ensure `.venv` is in `.gitignore` to avoid committing virtual environments

### Python Code
- Follow PEP 8 style guidelines
- Use type hints for all function signatures
- Prefer `pathlib.Path` over string paths
- Use `ruff` for linting and formatting
- Write docstrings in Google style format:
  ```python
  def function_name(param1: str, param2: int) -> bool:
      """Brief description of function.

      Args:
          param1: Description of param1
          param2: Description of param2

      Returns:
          Description of return value

      Raises:
          ValueError: Description of when this is raised
      """
  ```
- Use `logging` instead of `print()` statements
- Prefer dataclasses or Pydantic models for data structures
- Use context managers (`with` statements) for resource management

### TypeScript/React Code
- Use functional components with hooks
- Prefer named exports over default exports
- Use TypeScript strict mode - all variables must have explicit types
- Follow the existing component structure in `application/ui/src/`
- Use proper prop types and interfaces
- Implement error boundaries for robust error handling
- Use React Query for data fetching when applicable

### General Principles
- **DRY (Don't Repeat Yourself)**: Extract common logic into reusable functions/components
- **Single Responsibility**: Each function/class should have one clear purpose
- **Error Handling**: Always handle errors gracefully with informative messages
- **Testing**: Write unit tests for new functionality
- **Security**: Never hardcode secrets, use environment variables
- **Performance**: Consider performance implications, especially for ML operations

## Documentation Standards

### Code Comments
- Write self-documenting code with clear variable and function names
- Add comments only when the "why" is not obvious from the code
- Update comments when code changes
- Avoid redundant comments that just restate the code

### README Files
- Each major component should have a README.md
- Include:
  - Purpose and overview
  - Installation/setup instructions
  - Usage examples
  - Configuration options
  - Troubleshooting tips

### API Documentation
- Document all API endpoints with OpenAPI/Swagger specs
- Include request/response examples
- Document error responses and status codes
- Keep API documentation in sync with implementation

### Inline Documentation
- Use JSDoc for TypeScript/JavaScript
- Use docstrings for Python
- Document parameters, return values, and exceptions
- Include usage examples for complex functions

## Testing Guidelines

### Python Tests
- Use `pytest` for testing
- Run tests using `uv` (e.g., `uv run pytest`)
- Place tests in `tests/` directories
- Structure: `tests/unit/` and `tests/integration/`
- Name test files: `test_<module_name>.py`
- Name test functions: `test_<feature>_<scenario>`
- Use fixtures from `conftest.py` for common setup
- Aim for >80% code coverage
- Mock external dependencies
- Install test dependencies with `uv pip install -e ".[test]"` or similar

### TypeScript Tests
- Use Vitest for unit tests
- Use Playwright for E2E tests
- Place tests near the code they test or in `tests/` directory
- Name test files: `<component>.test.ts(x)`
- Use descriptive test names with `describe` and `it` blocks
- Mock API calls and external dependencies

## File Organization

### Backend Structure
```
application/backend/src/
├── api/          # API routes and endpoints
├── core/         # Core business logic
├── db/           # Database models and migrations
├── repositories/ # Data access layer
├── schemas/      # Pydantic schemas
├── services/     # Business logic services
└── utils/        # Utility functions
```

### Frontend Structure
```
application/ui/src/
├── api/          # API client and hooks
├── components/   # Reusable UI components
├── features/     # Feature-specific code
├── routes/       # Page components
└── assets/       # Static assets
```

### Library Structure
```
library/src/getiaction/
├── configs/      # Configuration management
├── data/         # Data loading and processing
├── inference/    # Inference engine
├── policy/       # Policy implementations
└── trainer/      # Training logic
```

## Git Commit Messages
- Use conventional commits format:
  - `feat:` for new features
  - `fix:` for bug fixes
  - `docs:` for documentation changes
  - `refactor:` for code refactoring
  - `test:` for adding tests
  - `chore:` for maintenance tasks
- Write clear, concise commit messages
- Reference issue numbers when applicable

## Pull Request Guidelines
- **Always use the PR template** (`.github/pull_request_template.md`)
- Fill out all relevant sections:
  - **Description**: Brief overview of changes
  - **Type of Change**: Mark the appropriate type
  - **Related Issues**: Link to relevant issues
  - **Changes Made**: List main changes
  - **Examples**: Include code examples, pseudo-code, or before/after comparisons to demonstrate the changes
  - **Breaking Changes**: Document any breaking changes
  - **Additional Notes**: Any context reviewers should know
- Provide clear examples showing:
  - Usage examples for new features
  - Before/after comparisons for refactors
  - High-level pseudo-code for complex changes
- Ensure PR title follows conventional commit format
- Request reviews from appropriate team members

## Performance Considerations
- Lazy load heavy dependencies in Python
- Use async/await for I/O operations
- Implement caching where appropriate
- Optimize database queries (use indexes, avoid N+1 queries)
- Profile code before optimizing
- Consider memory usage for ML models

## Security Best Practices
- Validate and sanitize all user inputs
- Use parameterized queries to prevent SQL injection
- Implement proper authentication and authorization
- Store secrets in environment variables or secret managers
- Keep dependencies updated
- Follow OWASP security guidelines

## AI/ML Specific Guidelines
- Document model architectures and hyperparameters
- Version control training configurations
- Log training metrics and artifacts
- Implement proper error handling for model inference
- Consider inference latency and throughput requirements
- Document model limitations and assumptions

## Questions to Consider Before Coding
1. Does this feature align with the project architecture?
2. Are there existing utilities/components I can reuse?
3. How will this be tested?
4. What error cases need to be handled?
5. Are there performance implications?
6. Does this need documentation?
7. Are there security considerations?

## When Suggesting Code Changes
- Explain the reasoning behind the changes
- Consider backward compatibility
- Highlight any breaking changes
- Suggest related tests that should be added/updated
- Point out any configuration changes needed
- Consider impact on existing functionality
